{
    "collab_server" : "",
    "contents" : "################################################################################################\n#                                  Lab -- out of range values\n#\n################################################################################################\n\n\n\n# create the range variable, the input data should have at least the following \n# variables included: LB_ORLO, LB_ORHI, LB_TESTC, sex, LB_STNRC\ncreate_range <- function(data){\n  \n  all_exist <- sum (names(data)  %in% c(\"LB_ORLO\", \"LB_ORHI\", \"LB_TESTC\", \"sex\", \"LB_STNRC\")) == 5\n  if(!all_exist) stop(\"at least one of the following \\n LB_ORLO, LB_ORHI, LB_TESTC, sex, LB_STNRC\\n does not exist or not named correctly, check your data\") \n  \n  low <- trimws(data$LB_ORLO)\n  high <- trimws(data$LB_ORHI)\n  testc <- trimws(data$LB_TESTC)\n  sex <- trimws(data$sex)\n  stnrc <- trimws(data$LB_STNRC)\n  \n  age <- rep(\"\", length(low))\n  range0 <- range1 <- rep(\"\", length(low))\n  \n  id1 <-  testc  ==\"ALP\" &  low == \"48\"  &  high == \"131\"\n  id2 <-  testc  ==\"ALP\" &  low  == \"45\" &  high  == \"120\"\n  id3 <-  testc  ==\"ALP\" &  low  == \"38\" &  high  == \"104\"\n  id4 <-  testc  ==\"ALP\" &  low  == \"37\" &  high  == \"115\"\n \n  age[id1 | id3] <- \"0-25\"; age[id2 | id4] <- \"26-99\"\n  \n  id5 <- low != \"\"\n  id6 <- high != \"\"\n  id7 <- grepl(\"NEG\", stnrc) | grepl(\"NOT\", stnrc) | grepl(\"TRAC\", stnrc) | grepl(\"POS\", stnrc) |\n         grepl(\"0-\", stnrc) | grepl(\"NON\", stnrc) | grepl(\"CLEAR\", stnrc) | grepl(\"YELLOW\", stnrc)\n  \n  range0[id5] <- paste(low[id5], high[id5], sep = \"-\")\n  range0[!id5 & id6] <- high[!id5 & id6]\n  range0[!id5 & !id6 & id7] <- stnrc[!id5 & !id6 & id7]\n  range0[!id5 & !id6 & !id7 & stnrc != \"\"] <- paste(\"<\", stnrc[!id5 & !id6 & !id7 & stnrc != \"\"])\n  \n  id8 <- sex == \"\"\n  id9 <- age == \"\"\n \n  range1[!id8 & id9 ] <- paste(substr(sex[!id8 & id9 ], 1, 1), \":\", range0[!id8 & id9 ], sep = \"\")\n  range1[!id8 & !id9] <- paste(age[!id8 & !id9], \"/\", substr(sex[!id8 & !id9], 1, 1), \":\", range0[!id8 & !id9], sep = \"\")\n  range1[id8  & id9] <- range0[id8 & id9]\n  range1[id8 & !id9] <- paste(age[id8 & !id9], \":\", range0[id8 & !id9])\n  \n  data$age <- age\n  data$range <- range1\n  return(data)\n}\n\n\n# create the laborig data, changing the format (or values) of some variables \ncreate_laborig <- function(lb_cq){\n  \n  laborig <- lb_cq %>% mutate(ptno = as.numeric(CLIENTID), \n                              sex = LB_SEX_C, \n                              LB_CAT = replace(LB_CAT, !(trimws(LB_CAT) %in% c('CHEM','HEME','UA','UDS','COAG','VIROL')), \"OTH\"), \n                              LB_ORRES = replace(LB_ORRES,trimws(toupper(LB_CMTST)) == \"CLOTTED UNABLE TO ANALYZE\", \"CUTA\"), \n                              LB_ORRES = replace(LB_ORRES,trimws(toupper(LB_CMTST)) == \"TOO NUMEROUS TO COUNT\", \"TNTC\"))\n  \n  id1 <- trimws(toupper(laborig$LB_TESTC)) == \"CK-MB\"\n  id2 <- trimws(toupper(laborig$LB_TESTC)) == \"A/G\"\n  id3 <- trimws(toupper(laborig$LB_TESTC)) == \"B/C\"\n  \n  \n  laborig <- laborig %>% mutate(LB_TESTC = replace(LB_TESTC, id1, \"CKMBB\"), \n                                LB_TESTC = replace(LB_TESTC, id2, \"AG\"), \n                                LB_TESTC = replace(LB_TESTC, id3, \"BC\"), \n                                LB_ORREU = replace(LB_ORREU, id2, \"RATIO\"),\n                                LB_ORREU = replace(LB_ORREU, id3, \"RATIO\")) \n  \n  laborig <- laborig %>% mutate(formatdate= parse_date_time(paste(ymd(LB_DAT), seconds_to_period(LB_TIM)), \"Ymd HMS\", truncated = 3)) %>%\n                         mutate(LB_TIM = format(formatdate, \"%H:%M:%S\")) %>%\n                         select(-formatdate)\n  \n   return(laborig)\n}\n\n\n\n# #' Find the normal range of each test code\n# #' \n# #' @title Find normal range\n# #' @param laborig  the dataset generated by \\code{create_laborig}\n# #' @return a data frame containing test codes and their corresponding normal range\n\n\nnormal_range <- function(laborig){\n\n  ranges <- laborig %>% select(LB_CAT, LB_TESTC, LB_ORLO, LB_ORHI, sex, LB_STNRC) %>%\n            arrange(LB_CAT, LB_TESTC, LB_ORLO, LB_ORHI, sex) %>%\n            distinct()\n  \n  male <- ranges %>% filter( trimws(toupper(sex)) %in% c(\"MALE\", \"M\")) %>%\n                  arrange(LB_CAT, LB_TESTC, LB_ORLO, LB_ORHI, LB_STNRC)\n  female <- ranges %>% filter( trimws(toupper(sex)) %in% c(\"FEMALE\", \"F\")) %>%\n                  arrange(LB_CAT, LB_TESTC, LB_ORLO, LB_ORHI, LB_STNRC)\n  \n  newrg <- full_join(male, female, by = c(\"LB_CAT\", \"LB_TESTC\", \"LB_ORLO\", \"LB_ORHI\", \"LB_STNRC\"))\n       \n  # create a sex variable, if sex is not empty, then this testcode is specific for this gender.\n  newrg$sex <- \"\"\n  id1 <- is.na(newrg$sex.y); id2 <- is.na(newrg$sex.x)\n  newrg$sex[!id1 & id2] <- newrg$sex.y[!id1 & id2]; newrg$sex[id1 & !id2] <- newrg$sex.x[id1 & !id2]\n  newrg <- newrg %>% select(-sex.x, -sex.y)\n  \n  # creating the range variable seems to be a complicated data step, so I write a function to do it.\n  tworg <- create_range(newrg)  # creates the range variable \n\n  tworg <- tworg %>% select(LB_CAT, LB_TESTC, sex, range ) %>% \n                     arrange(LB_CAT, LB_TESTC, sex, range) %>% \n                     mutate(sex = replace(sex, sex == \"\", \"A\"))\n  \n  temp1 <- tworg %>% group_by(LB_CAT, LB_TESTC, sex) %>% \n    filter(row_number()==1)\n  \n  temp2 <- tworg %>% group_by(LB_CAT, LB_TESTC, sex) %>% \n                filter(row_number()>1)\n  \n\n  \n  data1 <- left_join(temp1, temp2, by = c(\"LB_CAT\", \"LB_TESTC\", \"sex\")) %>%\n            mutate(range.y = replace(range.y, is.na(range.y), \"\"))\n  \n\n  final_range <- data1 %>% mutate(range = paste(range.x, range.y, sep =\" \"))  %>%\n                          mutate(range = replace(range, range.y==\"\", range.x), \n                                 lgthrge = nchar(range)) %>%  # define the length of each range\n                          select(-range.x, -range.y)     %>%  # don't need these two variable \n                          arrange(LB_CAT, LB_TESTC, range, lgthrge)    \n  \n  lb_orlog <- final_range %>% group_by(LB_CAT, LB_TESTC, range, lgthrge) %>%\n                          filter(row_number() == n())         # select if last.obs\n  return(lb_orlog)\n\n}\n\n\n\n# #' Find the out-of-range values\n# #' \n# #' @title Find OOR\n# #' @param lb_cq  the SAS dataset.\n# #' @param transpose   Should the data be transposed? FALSE by default (This corresponds to just filtering lb_cq by OOR conditions).\n# #' @return a data frame containing OOR\n\noor_value <- function(lb_cq, transpose = F){\n  \n  oor  <- create_laborig(lb_cq) %>%                   #  all cases of out of range values\n                   filter(trimws(LB_NRIND) != \"\" |\n                          trimws(LB_CSGFG) != \"\" |\n                          trimws(LB_PISIG) != \"\" |\n                          trimws(LB_UNSCH) != \"\" |\n                          trimws(toupper(PERIOD)) == \"EARLY TERMINATION\" |\n                          trimws(toupper(PERIOD)) == \"UNSCHEDULED\")\n\n  if (transpose) {\n    id1 <-  trimws(toupper(oor$PERIOD)) == \"EARLY TERMINATION\" | trimws(toupper(oor$PERIOD)) == \"UNSCHEDULED\"\n    oor$period_code <- oor$PERIOD\n    oor$period_code[!id1] = \"\"\n    \n    oor <- oor %>% mutate(LB_ORRES = paste(     # compbine all the abnormal signals\n                          trimws(LB_ORRES), \" \",\n                          trimws(LB_NRIND), \"\",\n                          trimws(LB_CSGFG), \"\",\n                          trimws(LB_PISIG), \"\",\n                          trimws(LB_UNSCH), \" \", \n                          trimws(period_code), sep = \"\"),\n                          LB_TESTC = paste(trimws(LB_CAT), trimws(LB_TESTC), sep = \"_\")) %>%\n                  select(ptno, sex, LB_DAT,LB_TIM, LB_TESTC, LB_ORRES, PERIOD, DAY, HOUR) %>%\n                  dcast(ptno + sex + PERIOD + DAY + HOUR + LB_DAT + LB_TIM ~ LB_TESTC, value.var = \"LB_ORRES\")     \n    \n  }\n                                \n  return(oor)\n  \n}\n\n\n##  read the full name of the codes and it's normal range indicator\n\nthe_code <- function(lb_cq){\n\n  lab_cat <- lb_cq %>% select(LB_CAT, LB_TESTC) %>% \n                  arrange(LB_CAT, LB_TESTC) %>% distinct()\n  \n  # the codes data is available once you load the pacage \"cdashQC\".\n  code1 <- right_join(codes %>% arrange(LB_TESTC), \n                      lab_cat %>% arrange(LB_TESTC), by = \"LB_TESTC\")\n  \n  # change \"~\" to \" \" in TTL, this will make the column names wrap\n  # create a new variable for LB_TESTC for easy selection\n  code1 <- code1 %>% mutate(var_name = paste(LB_CAT, \"_\", LB_TESTC, sep=\"\"),\n                            TTL = gsub(\"~\", \" \", TTL))     \n  # and also the normal ranges         \n  range0 <- create_laborig(lb_cq) %>% normal_range() %>% ungroup()\n  \n  if (length(unique(range0$sex)) > 1) {             # more than one gender is present\n    ranges <- range0  %>% dcast(LB_CAT + LB_TESTC ~sex, value.var= \"range\")\n    ids <- is.na(ranges$A)\n    ranges$A[ids] <- paste(ranges$FEMALE[ids], ranges$MALE[ids], sep = \" \")\n    ranges <- ranges %>% mutate(range = A) %>% select(LB_CAT, LB_TESTC, range)\n  }\n  else { # only one gender\n    ranges <-  range0 %>% select(LB_CAT, LB_TESTC, range)\n  }\n  \n  \n  # the full name will come with its normal range\n  code2 <- left_join(code1 %>% arrange(LB_CAT, LB_TESTC), \n                     ranges %>% arrange(LB_CAT, LB_TESTC), \n                     by = c(\"LB_CAT\", \"LB_TESTC\")) %>%\n    mutate(TTL = paste(TTL, range, sep = \" \"))\n  \n  \n  return(code2)\n}\n\n\n\n##  I don't know what this function is doing\n\noor_range <- function(lb_cq){\n   \n  laborig  <- oor_value(lb_cq)  # all cases of out of range values\n\n  new0 <- laborig %>% select(LB_CAT, LB_TESTC, LB_ORRES, LB_NRIND, LB_CSGFG, LB_PISIG)  %>%\n                      mutate(lgth = nchar(LB_ORRES))\n  \n  # This data set contains the length that each test code requires (by its actual value)\n  new1 <- new0 %>% arrange(LB_CAT, LB_TESTC, lgth) %>% \n                  distinct() %>%  # select distinct values\n                  group_by(LB_CAT, LB_TESTC, lgth) %>%\n                  filter(row_number() == n())  %>%  # keep rows having max(lgth) in each group\n                  select(-LB_ORRES)                 # drop LB_ORRES\n                \n    \n  lb_orlog <- normal_range(laborig)                 # get the normal range values \n  \n  new <- left_join(new1 %>% arrange(LB_CAT, LB_TESTC), \n                    lb_orlog %>% arrange(LB_CAT, LB_TESTC), \n                    by = c(\"LB_CAT\", \"LB_TESTC\") )\n  new$lgth <- ifelse(new$lgthrge > new$lgth, new$lgthrge, new$lgth )\n\n  #  pulling in the dataset from labcodes.mac to determine the title names \n  #  and the column width for this test in labcodes.mac.  If this width is \n  #  not as long as the longest lb_orres or range, the width is replaced with the   \n  #  longest lb_orres for your lab dataset     \n     \n  # codes <- read.csv(\"Y:/development/users/Zhuob01/R-template/data/CODES.csv\",stringsAsFactors=F) %>% \n  #             filter(lb_testc != \"\")\n  # names(codes) <- toupper(names(codes))\n  # codes$LB_TESTC <- as.character(codes$LB_TESTC)\n  \n  test <- right_join(codes %>% arrange(LB_TESTC), new, by = \"LB_TESTC\")\n  test$COLWIDE <- ifelse(test$lgth > test$COLWIDE |  is.na(test$COLWIDE), test$lgth, test$COLWIDE)\n  \n  codes2 <- test %>% mutate(colwd = COLWIDE + 4) %>% \n                  group_by(LB_CAT, TESTNUM, TTL) \n  \n  result <- list(laborig= laborig, codes = codes2)\n  \n  return(result)\n}\n\n\n\n# lb_orreu <- toupper(trimws(laborig$LB_ORREU))\n# id1 <-  lb_orreu == \"X 10^9/L\" | lb_orreu == \"X10^9/L\"\n# id2 <-  lb_orreu == \"X 10^12/L\" | lb_orreu == \"X10^12/L\"\n# id3 <- lb_orreu != \"\"\n# \n# one0 <- laborig %>% mutate( LB_ORREU = replace(LB_ORREU, id1, \"thou/uL\"), \n#                             LB_ORREU = replace(LB_ORREU, id2, \"mil/uL\"))\n# one0$LB_ORREU[id3] <-  paste(\"(\", trimws(one0$LB_ORREU[id3]), \")\", sep = \"\")  \n#\n# id5 <-  trimws(toupper(PERIOD)) != \"EARLY TERMINATION\" & trimws(toupper(PERIOD)) != \"UNSCHEDULED\"\n#\n# one1 <- one0 %>% select(LB_TESTC, LB_ORREU, LB_TEST)  %>%\n#                  arrange(LB_TESTC, LB_ORREU, LB_TEST) %>%\n#                  distinct()\n# \n# one <- left_join(one1, codes %>% arrange(LB_TESTC), by = \"LB_TESTC\") %>% \n#         mutate(COLWIDE = replace(COLWIDE, is.na(COLWIDE), 8) ) \n# id4 <- which(is.na(one$TTL))\n# one$TTL[id4] <- one$LB_TEST[id4]\n# one_update <- one %>% arrange(LB_TESTC, LB_TEST, LB_ORREU, TESTNUM, TTL, LB_CAT, COLWIDE)\n\n\n\n# #' Export the oor values\n# #' \n# #' @title Export the oor values by LB_CAT\n# #' @param lb_cq  the dataset lb_cq read from sas\n# #' @param ex  the dataset ex, used to get treatment information.\n# #' @return a data frame containing test codes and their corresponding normal range\n\n\nlab_rept <- function(lb_cq, ex, cat = \"UA\"){\n  \n  oor_all <- oor_value(lb_cq, transpose = T) # all cases of out of range values\n  \n  # get the treatment information\n  ex_trt <- ex %>% mutate(ptno = as.numeric(CLIENTID))  %>% select(ptno, EX_TRT_C) \n  \n  oor_value <- right_join(ex_trt %>% arrange(ptno, EX_TRT_C), \n                          oor_all %>% arrange(ptno), by = \"ptno\")\n  \n  # decide whether this CAT has oor listed in data \n    var_names <- names(oor_value)\n    cat_exist <- grepl(paste(cat, \"_\", sep = \"\"), var_names)\n    \n    if (any(cat_exist)){\n      oor <- oor_value %>% select(ptno, sex, EX_TRT_C, PERIOD, DAY, HOUR, LB_DAT, LB_TIM, starts_with(paste(cat, \"_\", sep = \"\")))\n      \n      return(oor)\n    }\n    \n    else { message(paste(\"Whoops! \", cat, \" does not have out-of-range values  \\nvariable OR 'LB_CAT' does not contain the value '\", cat, \"'\", sep = \"\"))}\n    \n}\n\n\n\n# #' print out the OOR values\n# #' \n# #' @title print oor values by LB_CAT\n# #' @param lb_cq  the dataset lb_cq read from sas\n# #' @param ex  the dataset ex, used to get treatment information.\n# #' @param cat which LB_CAT code will be used (\"UA\" for example)\n# #' @param var_per_block  how many variables to be shown in each block\n# #' @param digit_keep  the digit kept in the output. see \\code{kable()} for more details\n# #' @export\n\n\nprint_by_block <- function(data, col_label = names(data),  cat = \"UA\", \n                           var_per_block = 5, digit_keep = 2){\n  \n  # first, separate the data into two, one for fixed columns (those columns will be the same for all output)\n  part1 <- data %>% select(-starts_with( paste(cat, \"_\", sep = \"\")))\n  part2 <- data %>% select(starts_with( paste(cat, \"_\", sep = \"\")))\n  the_rest_name <-  names(part1)\n  cat_name <-  names(part2)\n  \n  ## devivde the variables into multiple blocks and print them block by block.\n  block <- ceiling(length(cat_name)/var_per_block)  # how blocks are needed\n  \n  for ( k in 1:block){\n    if(k == block){                        # if this is the last block\n      from1 <- (k-1)*var_per_block + 1\n      to1 <- length(cat_name)\n    }\n    else{         # if this is not the last block\n        from1 <- (k-1)*var_per_block + 1\n        to1 <-  k*var_per_block;\n    }\n      # c(from1, to1)\n      \n      # get the corresponding code\n      test_code <- as.character(cat_name[from1:to1])\n      col_to_show <- which(cat_name %in% test_code)\n      \n      part2_1 <- part2[, col_to_show]          # keep those names in this output\n      emt <- keep_non_empty(part2_1)           # get the index of empty columns and empty rows\n      part2_keep <- part2_1[, emt$keep_cols]   # remove empty columns\n      id1 <- is.na(part2_keep)                 # replace \"NA\" with \"\"\n      part2_keep[id1] <- \"\"\n      oor1 <- cbind(part1, part2_keep)         # remove empty rows\n      oor1 <- oor1[emt$keep_rows, ]\n      \n      # now the column names with desired lables\n      p1 <- ncol(part1)\n      col_num <- c(1:p1, p1 + from1:to1)\n      \n      col_name <- col_label[col_num]\n      rownames(oor1) <- NULL\n      # print out\n      print(kable(oor1, digits =digit_keep, table.attr='class=\"flat-table\"',\n                  col.names = col_name, caption = paste(cat, \":block \", k, \" of \", block, sep = \"\")))\n    }\n    \n    \n  }\n  \n\n\n\n\n\n\n#' print out the OOR values for all LB_CAT automatically. This function is built on top of customized_lab_rept()\n#' \n#' @title print OOR values for all LB_CAT\n#' @param lb_cq  the dataset lb_cq read from sas\n#' @param ex  the dataset ex, used to get treatment information.\n#' @param var_per_block  how many variables to be shown in each block\n#' @param digit_keep  the digit kept in the output. see \\code{\\link[knitr]{kable()}} for more details\n#' @export\n#' @examples\n#' lab_oor(lb_cq, ex, var_per_block = 6, digit_keep =3)\n\n\nlab_oor <- function(lb_cq, ex, var_per_block = 5, digit_keep = 2){\n  \n  laborig <- create_laborig(lb_cq)\n  cat_all <- unique(laborig$LB_CAT)  # how many LAB_CAT\n  full_name <- the_code(lb_cq)       # the code with its full name and normal ranges\n  \n  \n  for (i in 1: length(cat_all)){\n    \n    oor <- lab_rept(lb_cq, ex, cat=cat_all[i])  # create the lab oors\n    \n    if(!is.null(oor)){  # if the data is not empty\n      var1 <- names(oor)   # \n      id1 <- which(grepl(paste(cat_all[i], \"_\", sep = \"\"), var1))\n      \n      #try to get the full name in order\n      t1 <- data.frame(var_name = var1[id1], sorted = 1:length(id1), stringsAsFactors = F)\n      t2 <- left_join(t1 %>% arrange(var_name), \n                      full_name %>% arrange(var_name), by = \"var_name\")\n      # this should give the right name order\n      col_name_all <- c(var1[-id1], t2$TTL[order(t2$sorted)] )\n      # pass the name to the following function\n      print_by_block(oor, col_label = col_name_all, cat= cat_all[i], \n                     var_per_block=var_per_block, digit_keep = digit_keep)\n    }\n  \n  }\n  \n}\n\n",
    "created" : 1476395645584.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2930683619",
    "id" : "9834E00C",
    "lastKnownWriteTime" : 1476395863,
    "last_content_update" : 1476395863783,
    "path" : "~/cdashQC/cdashQC-master/R/cdash_lab_oor.R",
    "project_path" : "cdashQC-master/R/cdash_lab_oor.R",
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}