{
    "collab_server" : "",
    "contents" : "\n\n\n\n\n##########################################################################################\n#                                   USEFUL FUNCTIONS\n#\n##########################################################################################\n\n\n# read as many data sets as needed.\n#\n# @title race and ethnicity indicator, age.\n# @param data_vector  the name list of the data sets to be read\n# @param data_dir  where the data sets are stored\n# @return datasets  the data sets have been loaded\n# @export a list, each corresponding to a specific data set\n#\n#\n# read_all_data <- function(data_vector, data_dir){\n#   data_name <- c(\"ae\", \"bd\", \"cm\", \"cr\", \"cv\", \"dm\", \"ds\", \"eg\", \"ex\", \"hlt\", \"ie\", \"lb_cq\",\n#                  \"lbd\", \"mh\", \"ml\", \"pe\", \"su\", \"ti\", \"ur\", \"vs\", \"xd\")\n#   data <- list()\n#   ids <- which(data_name %in% data_vector)\n#   for(i in 1:length(ids)){\n#     per_data <- read_sas(paste(data_dir, data_name[ids[i]], \".sas7bdat\", sep = \"\"))\n#     data[[i]] <-  per_data\n#   }\n#   names(data) <- data_vector\n#   return(data)\n# }\n\n\n# create a cumalative count for each variable\n# so I can label \"QTCF\" as fig1QTCF, ... fig4QTCF, and fig1PR, fig2PR\ncumcount <- function(vec_c)\n{\n  vec_c <- as.character(vec_c)\n  seqs <- rep(0, length(vec_c))\n  items <- unique(vec_c)\n  tab <- table(vec_c)\n  for (k in 1:length(items))\n  {\n    c1 <- as.numeric(tab[k])\n    seqs[vec_c == names(tab)[k]] <- 1:c1\n  }\n  return(seqs)\n}\n\n\n\n#' falg variables by threshold\n#'\n#' @title label the variables of interest.\n#' @param data  the dataset to be flagged.\n#' @param thresh  a data frame returned by \\code{create_threshold()}\n#' @param prefix how will the flag variable be named (by adding a prefix).\n#' @param oor  is the current variable to be labeled for out of range?\n#' @return the data with variables flagged\n#' @export\n#' @examples\n#' a <- create_threshold(flagvar = \"PR\", lower = 150, upper = 200, include_lower = FALSE, include_upper = TRUE,  flg_label = \"^\")\n#' b <- create_threshold(flagvar = \"QTCF\",  upper = 430, flg_label = \"*\", add2existing = TRUE, thresh = a)\n#' data <- data.frame(PR = rnorm(10, 175, 25), QTCF = rnorm(10, 440, 20))\n#' flg_var(data, thresh=b, oor=c(TRUE, FALSE))\n#' \nflg_var <- function(data, thresh, prefix = \"flg\", oor= rep(F, nrow(thresh))){\n\n  n_var <- nrow(thresh)\n\n  seqs <- cumcount(thresh[, 1])\n  for (i in 1:n_var)\n  {\n    col_num <- which(trimws(toupper(names(data)))== toupper(thresh[i, 1]))  # column to be flagged\n\n\n    # flg only extreme values?\n    if (oor[i]){  # flag if a <  c1 or a > c2\n      ind_1 <- ifelse(thresh[i, 4], \"<=\", \"<\")\n      ind_2 <- ifelse(thresh[i, 5], \">=\", \">\")\n      \n      message(paste(\"flagging variable\", thresh[i, 1],  \"if it's\", ind_1, \n                    thresh[i, 2], \" or \", ind_2, thresh[i, 3]))\n\n      # for lower bound\n      if (thresh[i, 4]){\n        ind_low <- data[, col_num] <= thresh[i, 2]\n      }\n      else { ind_low <- data[, col_num] < thresh[i, 2] }\n\n      # for upper bound\n      if (thresh[i, 5]){\n        ind_upper <- data[, col_num] >= thresh[i, 3]\n      }\n      else { ind_upper <- data[, col_num] >= thresh[i, 3] }\n\n\n      row_num <- c(which(ind_low), which(ind_upper))\n      ncols <- ncol(data) + 1\n      data[, ncols] <- \"\"\n      data[row_num, ncols] <- as.character(thresh[i, 6])\n    }\n\n\n    else {   # flag when c1 < a < c2\n      \n      ind_1 <- ifelse(thresh[i, 4], \"<=\", \"<\")\n      ind_2 <- ifelse(thresh[i, 5], \"<=\", \"<\")\n      \n      \n      message(paste(\"flagging variable\", thresh[i, 1],  \"if\", thresh[i, 2], ind_1, thresh[i, 1], \n              ind_2, thresh[i, 3]))\n\n      # for lower bound\n      if (thresh[i, 4]){\n        ind_low <- data[, col_num] >= thresh[i, 2]\n      }\n      else { ind_low <- data[, col_num] > thresh[i, 2] }\n\n      # for upper bound\n      if (thresh[i, 5]){\n        ind_upper <- data[, col_num] <= thresh[i, 3]\n      }\n      else { ind_upper <- data[, col_num] < thresh[i, 3] }\n\n      row_num <- intersect(which(ind_low), which(ind_upper))\n      ncols <- ncol(data) + 1\n      data[, ncols] <- \"\"\n      data[row_num, ncols] <- as.character(thresh[i, 6])\n    }\n\n    names(data)[ncols] <- paste(prefix, seqs[i], tolower(thresh[i, 1]), sep = \"\")\n\n  }\n  return(data)\n}\n\n\n\n\n\n#' remove empty rows and empty columns of a data set\n#'\n#' @title remove empty rows and empty columns of a data set.\n#' @param data  the dataset\n#' @param pattern  the pattern to be considered as empty. \\code{NA} by default.\n#' @param return_truncated_data Controls the output.\n#' @return a data frame with empty rows and empty columns removed,  or a list containing the following elements.\n#' \\item{keep_rows}{a vector of \\code{TRUE} (for keeping row) or \\code{FALSE} (otherwise)}\n#' \\item{keep_rows}{a vector of \\code{TRUE} (for keeping column) or \\code{FALSE} (otherwise)}\n#' @export\n#' @examples \n#' data1 <- data.frame(x = rep(c(\"A\", NA, \"C\"), each = 3), y = NA, z = c(1:3, NA, 5:9) )\n#' keep_non_empty(data1, return_truncated_data = T)   \n#' d1 <- keep_non_empty(data1)\n\nkeep_non_empty <- function(data, pattern = NA, return_truncated_data = F){\n\n  col_total <- ncol(data)\n  row_total <- nrow(data)\n  if(is.na(pattern)){             # if want to remove NA\n    if (col_total == 1) {         # if there is only one column\n      keep_rows <- !is.na(data)\n    }\n    else {\n      keep_rows <- rowSums(is.na(data)) < col_total\n    }\n    if(row_total == 1){\n      keep_cols <- !is.na(as.vector(data))\n    }\n    else {\n      keep_cols <- colSums(is.na(data)) < row_total\n    }\n  }\n\n  else {     # if want to remove pattern , for example \"\" blank space\n    data_new <- apply(data, 2, trimws)\n    if (col_total == 1) {     # if there is only one column\n      keep_rows <- data_new == pattern\n    }\n    else {\n      keep_rows <- rowSums(data_new == pattern) < col_total\n    }\n    if(row_total == 1){\n      keep_cols <- data_new == pattern\n    }\n    else {\n      keep_cols <- colSums(data_new == pattern) < row_total\n    }\n  }\n\n\n  if(return_truncated_data){\n    data_result <- data.frame(data[keep_rows, keep_cols])\n    names(data_result) <- names(data)[keep_cols]\n    return(data_result)\n  }\n  else{\n    return(list(keep_rows = keep_rows, keep_cols = keep_cols))\n  }\n}\n\n\n\n\n#' create threshold data frame\n#'\n#' @title create threshold table (for flagging variable purpose).\n#' @param flagvar  the variable to be flagged\n#' @param lower   lower bound. Set to be \\code{-Inf} if none.\n#' @param upper  upper bound. Set to be \\code{Inf} if none.\n#' @param include_lower whether the lower bound should be included, \\code{TRUE} by default\n#' @param include_upper whether the upper bound should be included, \\code{FALSE} by default\n#' @param flg_label what label will be used to flag the variable\n#' @param add2existing  \\code{TRUE} or \\code{FALSE}. If \\code{TRUE}, must specify thresh.\n#' @param thresh  a data frame with three columns: first column, the variable to be flagged, second column, lower bound (if any); third column, upper bound (if any).\n#' @return a data frame\n#' @export\n#' @examples\n#' a <- create_threshold(flagvar = \"QTCF\", lower = 0, upper = 20, include_lower = FALSE, include_upper = TRUE,  flg_label = \"^\")\n#' b <- create_threshold(flagvar = \"PR\",  upper = 430, flg_label = \"*\", add2existing = TRUE, thresh = a)\n#' c <- create_threshold(flagvar = \"QRs\",  lower = 100, flg_label = \"%\",add2existing = TRUE, thresh = b)\n#' print(a); print(b);print(c);\n\n\ncreate_threshold <- function(flagvar, lower = -Inf, upper = Inf,\n                             include_lower = T, include_upper = F,\n                             flg_label = \"#\", add2existing= F, thresh = NULL){\n  if (!add2existing)\n  {\n    thresh1 <- data.frame(variable = flagvar, lower = lower, upper = upper,\n                          include_lower = include_lower,\n                          include_upper = include_upper,\n                          flg_label=flg_label)\n  }\n  else {\n    nx <- nrow(thresh)\n    newthresh <- data.frame(variable = flagvar, lower = lower, upper = upper,\n                            include_lower = include_lower,\n                            include_upper = include_upper,\n                            flg_label=flg_label)\n    names(newthresh) <- names(thresh)\n    thresh1 <- rbind(thresh, newthresh)\n  }\n  return(thresh1)\n}\n\n\n\n\n## \n# create protocol hour (PHOUR) if it's not already in the data set. \n\ncreate_phour <- function(data){\n  \n  if (!any(names(data) == \"PHOUR\")) {\n    message(\"Variable 'PHOUR' not detected, creating it by concatnating variables 'DAY' and 'HOUR'\")\n    data <- data %>% mutate(PHOUR = paste(\"Day\", DAY, \"Hour\", round(HOUR, 2)))  \n  }\n  \n  return(data)\n  \n}\n\n\n\n\n\n\n\n# get the summary statistics\n#' @title get summary statistics\n#' @param data the data \n#' @param group which column should be the group \n#' @param var which columns are used to summarize\n#' @param na.rm should missing value be removed? \\code{TRUE} by default.\n#' @return a data frame\n#' @export \n#' @examples \n#' SEQ = rep(c(\"A\", \"B\", \"C\"), 3); subtype = sample(c(\"ONE\", \"TWO\", \"THREE\"), 9, replace = TRUE)\n#' data <- data.frame(SEQ, subtype, BMI = rnorm(9, 25, 4), HEIGHT = rnorm(9, 175,3)) \n#' get_summary_stats(data, group = \"SEQ\", var = \"subtype\")\n#' get_summary_stats(data, group = \"SEQ\", var = \"BMI\")\n\nget_summary_stats <- function(data, group = \"EX_TRT_C\", var = \"race\", na.rm =TRUE){\n\n  var_col <- which( names(data)== var)\n  var_attrib <- is.numeric(as.vector(data[, var_col]))\n  \n  if(!var_attrib){   # if it's not numerical, treate it as categorical \n    \n    result <- as.data.frame(ftable(data %>% select_(var, group))) %>% \n      spread_(group, \"Freq\") %>% mutate(trait = toupper(var))\n    names(result)[1] <- \"type\"\n    \n    t1 <- result %>% select(trait, type) \n    t2 <- result %>% select(-trait, -type)\n    \n    result1 <- bind_cols(t1, t2)\n  }\n  else{  # if it's numerical \n    result <- data %>% select_(var, group) %>% \n      group_by_(group) %>% \n      summarise_(N = interp(~sum(val >0, na.rm = na.rm), val = as.name(var)), \n                 MEAN = interp(~mean(val, na.rm = na.rm), val = as.name(var)),\n                 SD = interp(~sd(val, na.rm = na.rm), val = as.name(var)), \n                 MINIMUM = interp(~min(val, na.rm = na.rm), val= as.name(var)), \n                 MEDIAN = interp(~median(val, na.rm = na.rm), val = as.name(var)), \n                 MAXIMUM = interp(~max(val, na.rm= na.rm), val =as.name(var)))\n    \n    result0 <- result %>% melt(id = group, variable.name = \"type\") %>%\n      spread_(group, \"value\")  %>%  mutate(trait = var)\n    \n    p1 <-  result0 %>% select(trait, type)\n    p2 <-  result0 %>% select(-trait, -type)\n    result1 <- bind_cols(p1, p2) \n    \n  }\n  \n  return(result1)\n}\n\n\n#' count to percent\n#' \n#' @title add percentage to a frequency table\n#' @param data the data should contain at least 2 columns\n#' @param var1 which column should be the group \n#' @param var2 which columns are used to calculate percentage (could be a vector)\n#' @param digit_keep how many digits should be kept. \n#' @return a data frame\n#' @export\n#' @examples \n#' trait = rep(c(\"A\", \"B\", \"C\"), 3); subtype = paste(trait, rep(1:3, each=3), sep = \"\")\n#' data <- data.frame(trait, subtype, count1 = rpois(9, 5), count2 = rpois(9, 10)) \n#' count_percent(data, var1= 1, var2 = 3:4)\n#' \n#' r1 <- get_summary_stats(eg, group = \"PERIOD\", var = \"EG_TEST\")\n#' count_percent(r1, var1 = 1, var2 = 3:5)\ncount_percent <- function(data, var1, var2, digit_keep = 3){\n\n  data <- data[order(data[, var1]), ] # sort by the group variable \n  trait <- unique(data[, var1] )\n  ntrait <- length(trait)\n  result <- data.frame(matrix(NA, nrow = 0, ncol=length(var2))) \n  names(result) <- names(data)[var2]\n  \n  for ( i in 1:ntrait){\n    if (length(var2) > 1){\n      p1 <- as.matrix(data[data[, var1]==trait[i], var2])\n      pct <- sweep(p1, 2, colSums(p1), \"/\")   # convert to percentage\n      ctpct <- paste(p1, \" (\", round(pct, digit_keep)*100, \"%)\", sep = \"\")\n      ctpct <- data.frame(matrix(ctpct, nrow=nrow(p1), ncol= ncol(p1), byrow = F))\n    }\n    else {\n      p1 <- as.vector(data[data[, var1]==trait[i], var2])\n      pct <- p1/sum(p1)\n      ctpct <- paste(p1, \" (\", round(pct, digit_keep)*100, \"%)\", sep = \"\")\n      ctpct <- data.frame(ctpct)\n    }\n    names(ctpct) <- names(data)[var2]\n    result <- rbind(result, ctpct)\n  }\n\n  r1 <- as.data.frame(data[, -var2])\n  names(r1) <- names(data)[-var2]\n  \n  result1 <- dplyr::bind_cols(r1, result)\n  return(result1)\n}\n\n\n\n",
    "created" : 1476382456265.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3153043195",
    "id" : "5337530A",
    "lastKnownWriteTime" : 1476396026,
    "last_content_update" : 1476396026714,
    "path" : "~/cdashQC/cdashQC-master/R/useful.R",
    "project_path" : "cdashQC-master/R/useful.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}