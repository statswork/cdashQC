{
    "collab_server" : "",
    "contents" : "\n\n# find which variables have negative hours, note if \"negativeHour == F\" that means we should use screen or other (PHOUR) as baseline\n\nnegative_hour <- function(temp1){\n  if (all(names(temp1) %in% \"TEST_CODE\")){\n    stop(\"YOU must change the variable name to 'TEST_CODE'. Usually, this variable contains all the test categories!\")\n  }\n  \n  testc<- temp1 %>% select(TEST_CODE) %>% distinct()  # all the test codes\n  testc_Negative <- rep(F, nrow(testc)) # create an indicator to specify whether this code has negative hours as baseline\n  for( i in 1: nrow(testc)){\n    ids <- temp1$TEST_CODE == as.character(testc[i, 1])\n    hours <- unique(temp1$HOUR[ids])\n    if (any(hours<0, na.rm = T)) {testc_Negative[i] <- T }\n    else {testc_Negative[i] <- F}\n  }\n  testc$HasNegativeHour <- testc_Negative\n  data.frame(testc)\n}\n\n### find the name of the test code: it should end with var_identifier. \n\nfind_test <- function(data, var_identifier = \"_TEST\"){\n  # this piece of code detects which variable name should be the variable name of tests\n  short_code <- c(\"EG\", \"VS\", \"LB\")\n  index <- rep(F, length(short_code))\n  for (i in 1:length(short_code)){\n    index[i] <- any(grepl(paste(short_code[i], \"_\", sep = \"\"), names(data)))\n  }\n  if (sum(index)>1) stop(\"Name conflict!!\")\n  # keep track of the original name\n  complete_identifier <- paste(short_code[index], var_identifier, sep = \"\")\n  return(complete_identifier)\n}\n\n\n# find base line for the test\n# create an extra column indicator\n\n#' find the baseline hour for each test category\n#' \n#' @title find the baseline hour for each test\n#' @param data currently support \\code{vs}, \\code{eg} and \\code{lb_cq}.\n#' @param var_identifier a string that can be used to identify the variable name e.g.(\\code{VS_TEST, EG_TEST, LB_TEST})\n#' @return a data frame where by-subject baseline hour is determined. \n#' @export\n#' @examples \n#' # the following two will give you exactly the same result\n#' r1 <- find_base_phour(vs)\n#' r2 <- find_base_phour(vs, var_identifier = \"VS_TEST\")\n#' \n#' # If you want to find baseline hours for eg, the following two methods are equivalent\n#' r3 <- find_base_phour(eg)\n#' r4 <- find_base_phour(eg, var_identifier = \"EG_TEST\")\n#' \n\nfind_base_phour <- function(data, var_identifier = \"_TEST\"){\n  \n  # find the corresponding variable name of the test\n complete_identifier <- find_test(data, var_identifier)\n\n  \n  sort_via <- which(names(data) == complete_identifier)\n  names(data)[sort_via] <- \"TEST_CODE\"      # give it a new name for easy data manipulation.\n  \n  hour_ind <- negative_hour(data)           # find which test has negative hours \n  \n  data2 <- inner_join(data %>% arrange(TEST_CODE), \n                      hour_ind %>% arrange(TEST_CODE),\n                      by = \"TEST_CODE\") \n  \n \n  # subset to have negative hours as baseline\n  baseline1 <-  data2 %>% filter(HasNegativeHour==T) %>%\n          filter(HOUR < 0  & !is.na(HOUR)) %>%                 # has negative hour as baseline\n          arrange(CLIENTID, PERIOD, TEST_CODE, DAY, HOUR) %>%  # sort the related variables\n          group_by(CLIENTID, PERIOD, TEST_CODE) %>%                \n          slice(n())   %>%                                     # the hour of last observation will correspond to baseline hour\n          select(CLIENTID, PERIOD, TEST_CODE, PHOUR)  %>%\n          mutate(status= \"BASELINE\")\n         \n  # find test categories that have NA (PERIOD = SCREEN) as baseline\n  baseline2 <- data2 %>% filter(HasNegativeHour==F) %>%\n          filter(is.na(HOUR)) %>%\n          arrange(CLIENTID, PERIOD, TEST_CODE, DAY, HOUR) %>%  # sort the related variables\n          group_by(CLIENTID, PERIOD, TEST_CODE) %>%                \n          slice(n())   %>%                                     # the hour of last observation will correspond to baseline hour\n          select(CLIENTID, PERIOD, TEST_CODE, PHOUR)  %>%\n          mutate(status= \"BASELINE\")\n        \n  baseline_hour <- bind_rows(baseline1, baseline2)\n  temp_name <- which(names(baseline_hour) == \"TEST_CODE\")\n  names(baseline_hour)[temp_name] <- complete_identifier  # change the code name to its original name\n  \n  dat <- baseline_hour %>% ungroup() %>% arrange(CLIENTID, PERIOD, PHOUR)\n  return(dat)\n}\n\n\n\n\n#' create an extra column inidcating whether the current row should be considered as baseline. \n#' \n#' @title create baseline indicator.\n#' @param data currently support \\code{vs}, \\code{eg} and \\code{lb_cq}.\n#' @param var_identifier a string that can be used to identify the variable name e.g.(\\code{VS_TEST, EG_TEST, LB_TEST})\n#' @return a data frame with an extra column \\code{status} whose value could be one of \\code{BASELINE}, \\code{POSTDOSE} and \\code{PREDOSE (NOT BASELINE)} \n#' @export\n#' @seealso \\code{\\link{find_base_hour}}\n\n\ncreate_baseline <- function(data, var_identifier = \"_TEST\"){\n  \n  data <- create_phour(data)\n  \n  # find the baseline hours for each test category\n  basehour <- find_base_phour(data, var_identifier)\n  var_sort <- names(basehour)[!names(basehour) %in% c(\"status\")]  # sort by these variables\n  \n  # merge to the original data to create an extra column showing whether it's baseline or not.\n  data1 <- left_join(data %>% arrange_(.dots = var_sort), \n              basehour %>% arrange_(.dots= var_sort), \n              by = var_sort)\n  \n  id1 <- is.na(data1$status) & (is.na(data1$HOUR) | data1$HOUR < 0)\n  id2 <- is.na(data1$status) & ( data1$HOUR >= 0)\n  id3 <- toupper(trimws(data1$PERIOD)) == \"SCREEN\"\n  \n  data1$status[id1] <- \"PREDOSE (NOT BASELINE)\"\n  data1$status[id2] <- \"POSTDOSE\"\n  data1$status[id3] <- \"SCREEN\"\n  \n  return(data1)\n}\n\n\n\n\n\n\n\n\n",
    "created" : 1476395006294.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2257120275",
    "id" : "BD487105",
    "lastKnownWriteTime" : 1476395254,
    "last_content_update" : 1476395254041,
    "path" : "~/cdashQC/cdashQC-master/R/baselines.R",
    "project_path" : "cdashQC-master/R/baselines.R",
    "properties" : {
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}