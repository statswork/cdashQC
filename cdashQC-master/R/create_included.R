# create seqtest data
# the returned data set should have all sequences and an indicator showing if subject completed all sequences

create_seqtest <- function(ex){
  
  med <- ex %>% mutate(EX_TRT_C = substr(EX_TRT_C, 4, 4),   # get the treatment lable
                       pern = as.numeric(gsub("A|B|C|D|E|F", "", PERIOD)) # remove A or B or C, ect.  equivalent to compress() in SAS
                       )
  
  medseq <- med %>% arrange(CLIENTID, pern, EX_TRT_C) %>% 
    group_by(CLIENTID, pern, EX_TRT_C) %>% filter(row_number()==1)
  
  
  # total number of period
  totper <- length(unique(med$pern))
  tottrt <- length(unique(med$EX_TRT_C))
  
    
  seqtest <- dcast(medseq, CLIENTID ~ pern, value.var="EX_TRT_C")
  ## add a prefix to the transformed variable
  id0 <- which(!(names(seqtest)%in% c("CLIENTID", "pern")))
  names(seqtest)[id0] <- paste("dosed_", names(seqtest)[id0], sep = "") 
  
  
  # replace "NA" with "_"
  char_replace <- as.list(rep("_", length(id0)))
  names(char_replace) <- names(seqtest)[id0]
  seqtest <- replace_na(seqtest, replace=char_replace)
  
  # combine the treatments to make a sequence
  seqtest <- unite_(seqtest, "seq", names(seqtest)[id0], sep ="", remove = F)
  
  # set trtflg=* if trt is missing in a period;
  seqtest <- seqtest %>% mutate(trtflg = ifelse(grepl("_", seq), "*", ""))
  
  seqtest$rseq <- seqtest$seq
  
  return(seqtest)
  
}

# create chkseq data
# the returned data set should have all sequences and an indicator showing if subject checked in at least one sequence

create_chkseq <- function(dm, cr){
  
  # add all ptno from the DM dataset to add any ptno that did not get dosed
  dem <- dm %>% select(CLIENTID, SCRID, CLIENTID)
  
  # additional code to determine if a subject checked in in each period
  chk <- cr %>% mutate(chk = "Y",
                       pern = as.numeric(gsub("A|B|C|D|E|F", "", PERIOD))) %>%
                select(CLIENTID, CR_DAT, pern, chk) %>%
                arrange(CLIENTID, pern, chk) %>% 
                group_by(CLIENTID, pern, chk) %>%
                filter(row_number()==1)
  
  # Creating the chkseq variable which is a concatentation of the Y or N    in
  # period 1, the check in for period 2,.....                                 
  
  chkseq <- dcast(chk, CLIENTID + CR_DAT ~ pern, value.var = "chk")
  # add a prefix to the variables generated by pern.
  id1 <- which(!(names(chkseq)%in% c("CLIENTID", "CR_DAT")))
  names(chkseq)[id1] <- paste("chk_in_", names(chkseq)[id1], sep = "") 
  # this dcast is not exactly what proc transpose does, need one more step
  if (length(id1)>1){
    base <- chkseq %>% select(CLIENTID, CR_DAT, chk_in_1) %>% filter(!is.na(chk_in_1))
    for (i in 2:length(id1)){
      
      per_i <- chkseq %>% select(CLIENTID, matches(paste("chk_in_", i, sep = ""))) 
      row_keep <- !is.na(per_i[, 2])
      per_i <- per_i[row_keep, ]
      
      base <- left_join(base %>% arrange(CLIENTID), 
                        per_i %>% arrange(CLIENTID),
                        by = c("CLIENTID"))
    }
    chkseq <- base
  }

  
  ## decide if there is subject who never checked in (will be flagged with *) 
  col_ids <- starts_with("chk_in_", vars = names(chkseq))
  ch2 <- as.list(rep("_", length(col_ids)))
  names(ch2) <- names(chkseq)[col_ids]
  chk_in_0 <- replace_na(chkseq, replace = ch2)
  chk_in_0 <- unite_(chk_in_0,"CHECKED", names(chk_in_0)[col_ids], sep= "", remove=F)
  id_checked <- grepl("Y|YES", toupper(chk_in_0$CHECKED))
  chk_in_0$chkflg <-  ifelse(id_checked, "", "*")
  
  return(chk_in_0)
  
  
}



## create disposition table
create_dis <- function(ex, ds){
  med <- ex %>% mutate(EX_TRT_C = substr(EX_TRT_C, 4, 4),   # get the treatment lable
                       pern = as.numeric(gsub("A|B|C|D|E|F", "", PERIOD)) # remove A or B or C, ect.  equivalent to compress() in SAS
                       )
  totper <- length(unique(med$pern))
  
  dis <- ds 
  ds_ans_exist <- any(names(dis) %in% "DS_ANS")
  if(ds_ans_exist){
    dis$comp <- ifelse(dis$DS_ANS %in% c("YES", "Y"), "Y", "")
  } else{
    dis$comp <- ifelse(trimws(toupper(dis$DS_TRM_D)) == "COMPLETED", "Y", "N")
  }
  names(dis)[ncol(dis)] <- paste("comp_", totper, sep = "")
  
  dis <- dis %>% select(CLIENTID, starts_with("comp_"), DS_SPEC)  # the SAS code has DS_ANS included
  return(dis)  
}


#' create_included.
#'
#' @title do what new_create_included does.
#' @param ex  the dataset ex read from sas
#' @param dm  the dataset dm read from sas
#' @param cr  the dataset cr read from sas
#' @param ds  the dataset ds read from sas
#' @return the included data set
#' @export
#'
#'

create_included <- function(ex, dm, cr, ds){
  
  dem <- dm  %>% select(CLIENTID, SCRID, CLIENTID)
  seqtest <- create_seqtest(ex)
  chk_in <- create_chkseq(dm, cr)
  dis <- create_dis(ex, ds)
  
  seqtest1 <- full_join(seqtest %>% arrange(CLIENTID), 
                        full_join(dem %>% arrange(CLIENTID),
                                  full_join(chk_in %>% arrange(CLIENTID), 
                                            dis %>% arrange(CLIENTID), by = "CLIENTID"),
                                  by = "CLIENTID"), 
                        by = "CLIENTID") %>%
              mutate(flag = "")
  names(seqtest1)[grepl("comp_", names(seqtest1)) > 0] <- "compprot"
  id3 <- seqtest1$trtflg != "" | seqtest1$chkflg != "" |seqtest1$compprot != "Y" # the SAS code has DS_ANS included
  seqtest1$flag[id3] <- "*"
  

  seqtest2 <- seqtest1 %>% select(-trtflg, -chkflg, -DS_SPEC) %>% 
              mutate(safeanal = "Y",
                     pkanal = ifelse(flag == "", "Y", "N"))

  
  names(seqtest2) <- toupper(names(seqtest2))
  return(seqtest2)
}





############################### OTHER CREATED FUNCTIONS ##############################################

## 
# create protocol hour (PHOUR) if it's not already in the data set. 
#' Create protocol hour variable if it's not already in the data set.
#' @title Create protocol hour
#' @param data either \code{eg}, \code{vs} or \code{lb_cq}
#' @return the same data set with one more column if Phour is created, otherwise returns the input data.
#' @export


create_phour <- function(data){
  
  if (!any(names(data) == "PHOUR")) {
    message("Variable 'PHOUR' not detected, creating it by concatnating variables 'DAY' and 'HOUR'")
    data <- data %>% mutate(PHOUR = paste("Day", DAY, "Hour", round(HOUR, 2)))  
  }
  
  return(data)
  
}

##########




